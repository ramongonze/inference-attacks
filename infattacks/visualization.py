import numpy as np
from humanize import intword
import matplotlib.pyplot as plt
import infattacks
from matplotlib.colors import Normalize, LinearSegmentedColormap

class VisualizeRisk:
    """
    A class for visualizing risk data.

    This class provides methods to visualize data generated by an Attack class. It's possible to make scatter plots to see the vulnerability for different combinations of QIDs and bar plot for the individual posterior vulnerabilities  for a given combination of QIDs.
    """

    def __init__(self, attack:infattacks.attacks.Attack):
        """Initialize the VisualizeRisk object.

        Parameters:
            attack (Attack): Attack object.
        """
        self.attack = attack
    
    def _build_graph(self, x, y, show_graph, save_graph, format, attack_type, sensitive=None):
        if isinstance(self.attack, infattacks.Probabilistic):
            title = "Probabilistic"
        elif isinstance(self.attack, infattacks.Deterministic):
            title = "Deterministic"

        cmap = LinearSegmentedColormap.from_list("red_to_blue", [(1, 0, 0), (0, 0, 1)])

        # Plot for left y-axis (proportion of people)
        y_left = y
        ax1 = plt.subplot()
        cmap = LinearSegmentedColormap.from_list("blue_to_red", [(0, 0, 1), (1, 0, 0)])
        norm = Normalize(vmin=min(y_left), vmax=max(y_left))
        plt.scatter(x, y_left, c=y_left, cmap=cmap, norm=norm, alpha=0.5, s=70, label="Posterior")
        plt.xlabel("Number of QIDs")
        plt.ylabel("Vulnerability")
        plt.ylim((0,1))
        plt.yticks(np.array(range(0,101,10))/100)

        # Plot for right y-axis (number of people)
        y_right = np.array(y)*self.attack.data.num_rows
        ax2 = ax1.twinx()
        ax2.ticklabel_format(style="plain")
        ax2.scatter(x, y_right, alpha=0)
        plt.ylabel("Number of Individuals")
        plt.ylim((0,self.attack.data.num_rows))

        plt.xticks(range(1,self.attack.post_comb_qids_reid["num_qids"].max()+1))

        if attack_type == "reid":
            plt.title(title + " Re-identification Attack")
        elif attack_type == "ai":
            plt.title(title + f" Attribute-inference Attack - {sensitive}")
        
        ax1.legend()
        ax1.grid(.3, linestyle="--")

        fig = plt.gcf()
        fig.set_size_inches(10, 6)
        
        if save_graph:
            plt.savefig(save_graph, format=format, bbox_inches="tight")
        
        if show_graph:
            plt.show()

    def plot_comb_qids_reid(self, show_graph=True, save_graph=None, format=None) -> None:
        """
        Plot a graph depicting the vulnerabilities in Re-identification attacks generated by Attack.post_comb_qids.

        Parameters:
            show_graph (bool, optional): Whether to display the graph on the screen. Default is True.
            save_graph (str, optional): File path to save the graph. If None, the graph won't be saved. Default is None.
            format (str, optional): The file format for saving the graph (e.g., 'png', 'pdf'). Applicable only if `save_graph` is provided.

        Note:
            - The graph illustrates the prior and posterior vulnerabilities for Re-identification attacks.
            - The x-axis represents the number of quasi-identifiers (QIDs), while the y-axis represents the vulnerability.
            - The graph includes both prior (baseline) and posterior (calculated) vulnerabilities.
            - The graph can be displayed, saved to a file, or both based on the specified parameters.
        """
        prior = self.attack.prior_reid()
        plt.hlines(prior, 1, self.attack.post_comb_qids_reid["num_qids"].max(), label="Prior")
        
        x = self.attack.post_comb_qids_reid["num_qids"]
        y = self.attack.post_comb_qids_reid["post_vul"]
        self._build_graph(x, y, show_graph, save_graph, format, "reid")

    def plot_comb_qids_ai(self, sensitive:str, show_graph=True, save_graph=None, format=None) -> None:
        """
        Plot a graph for Attribute-inference attacks.

        This function generates and displays a graph illustrating the prior and posterior vulnerability
        for Attribute-inference attacks on a specific sensitive attribute across different numbers of quasi-identifiers (QIDs).

        Parameters:
            sensitive (str): The sensitive attribute for which to plot the graph.
            show_graph (bool, optional): Whether to display the graph on the screen. Default is True.
            save_graph (str, optional): File path to save the graph. If None, the graph won't be saved. Default is None.
            format (str, optional): The file format for saving the graph (e.g., 'png', 'pdf'). Applicable only if `save_graph` is provided.

        Note:
            - The graph illustrates the prior and posterior vulnerabilities for Attribute-inference attacks.
            - The x-axis represents the number of quasi-identifiers (QIDs), while the y-axis represents the vulnerability.
            - The graph includes both prior (baseline) and posterior (calculated) vulnerabilities.
            - The graph can be displayed, saved to a file, or both based on the specified parameters.
        """
        prior = self.attack.prior_ai()[sensitive]
        plt.hlines(prior, 1, self.attack.post_comb_qids_ai["num_qids"].max(), label="Prior")
        
        x = self.attack.post_comb_qids_ai["num_qids"]
        y = self.attack.post_comb_qids_ai["post_vul_"+sensitive]
        self._build_graph(x, y, show_graph, save_graph, format, "ai", sensitive=sensitive)

    def plot_hist(self, histogram_counts, title, hist_bin_size=5, show_hist=True, save_hist=None, format=None):
        """
        Plot a histogram of individual posterior vulnerabilities. The histogram is generated by either `Attack.post_reid` or `Attack.post_ai` methods.

        Parameters:
            histogram_counts (list or np.ndarray): List or array containing the counts for each bin of the histogram. It's generated by `Attack.post_reid, `Attack.post_ai` and `Attack.post_comb_qids` methods.
            title (str): The title of the histogram plot.
            hist_bin_size (int, optional): Size of each histogram bin, in percentage. Defaults to 5.
            show_hist (bool, optional): Whether to display the histogram on the screen. Default is True.
            save_hist (str, optional): File path to save the histogram. If None, the histogram won't be saved. Default is None.
            format (str, optional): The file format for saving the histogram (e.g., 'png', 'pdf'). Applicable only if `save_hist` is provided.

        Note:
            - The x-axis labels represent the posterior vulnerability (i.e., intervals of probabilities).
            - The y-axis represents the number of people with the respective posterior vulnerability in a given bin.
        """
        histogram = dict()
        for i in range(len(histogram_counts)):
            if i < len(histogram_counts) - 1:
                histogram[f"[{i * (hist_bin_size / 100):.2f},{(i + 1) * (hist_bin_size / 100):.2f})"] = int(histogram_counts[i])
            else:
                histogram[f"[{i * (hist_bin_size / 100):.2f},{(i + 1) * (hist_bin_size / 100):.2f}]"] = int(histogram_counts[i])

        x_labels = histogram.keys()
        x = list(range(len(x_labels)))
        y_right = np.array(list(histogram.values())) # Absolute 
        y_left = y_right/y_right.sum() # Proportions

        # Plot for left y-axis (proportion of people)
        ax1 = plt.subplot()
        ax1.grid(.3, linestyle="--")
        cmap = LinearSegmentedColormap.from_list("blue_to_red", [(0, 0, 1), (1, 0, 0)])
        norm = Normalize(vmin=0, vmax=len(x_labels))
        plt.bar(x, y_left, color=cmap(norm(x)))
        plt.xlabel("Posterior vulnerability")
        plt.xticks(x, x_labels, rotation=90)
        plt.ylabel("Proportion of individuals")
        plt.ylim((0,1))
        plt.yticks(np.array(range(0,101,10))/100)

        # Plot for right y-axis (number of people)
        ax2 = ax1.twinx()
        # ax2.ticklabel_format(style="plain")
        ax2.bar(x,y_left, alpha=0)
        plt.ylabel("Number of Individuals")
        plt.ylim((0,self.attack.data.num_rows))

        plt.title(title)

        fig = plt.gcf()
        fig.set_size_inches(10, 6)

        if save_hist:
            plt.savefig(save_hist, format=format, bbox_inches="tight")
        
        if show_hist:
            plt.show()
